import csv
import json
import random
from typing import Optional
import typing
from app.config import paths

PLAYERS_FILE = paths.USER_PLAYERS_CSV
STATE_FILE = paths.BASE_DIR / "player_selector_state.json"


def load_players():
    with open(PLAYERS_FILE, mode='r', encoding='utf-8') as file:
        reader = csv.DictReader(file)
        return list(reader)


def load_state():
    if not STATE_FILE.exists():
        return {
            "global": [],
            "subteam": {},
            "sex": {}
        }
    return json.loads(STATE_FILE.read_text(encoding='utf-8'))


def save_state(state):
    STATE_FILE.write_text(json.dumps(state, indent=2), encoding='utf-8')


def reset_filter(state: dict, filter_type: str, key: str):
    """Reset a filter list (subteam or sex)"""
    if filter_type not in state:
        state[filter_type] = {}
    state[filter_type][key] = []


def select_from_filtered_list(
    players: list,
    used_player_ids: set,
    reset_filter: typing.Callable,
):
    available_players = [p for p in players if p["id"] not in used_player_ids]

    if not available_players:
        reset_filter()
        available_players = players
        used_player_ids.clear()

    selected_player = random.choice(available_players)
    used_player_ids.add(selected_player["id"])
    return selected_player


def select_random_player(
    subteam: Optional[str] = None,
    sex: Optional[str] = None
):
    """Select a random player from the list and keep track of the previously
    selected one. Main goal is to have a different player in each stories
    generated by scorecast for representation equity

    Args:
        subteam (Optional[str], optional): Subteam filtering. Defaults to None.
        sex (Optional[str], optional): Sex filtering. Defaults to None.

    Returns:
        dict: Player dict
    """
    players = load_players()
    used_players = load_state()
    print(f"Current state before selection: {used_players}")

    # Defining used player sets
    by_default_used = set(used_players["global"])
    by_subteam_used = set(used_players["subteam"].get(
        subteam, [])) if subteam else set()
    by_sex_used = set(used_players["sex"].get(sex, [])) if sex else set()

    filtered_players = players

    # Filtering by sex has priority over subteam
    if sex != "mixed" and sex is not None:
        filtered_players = [p for p in filtered_players if p["sex"] == sex]

        selected = select_from_filtered_list(
            filtered_players,
            by_sex_used,
            lambda: reset_filter(used_players, "sex", sex)
        )

        used_players["sex"][sex] = list(by_sex_used)

        save_state(used_players)
        print(f"Selected player: {selected['id']}")
        return selected

    if subteam:
        filtered_players = [
            p for p in filtered_players if p["subteam"] == subteam]

        selected = select_from_filtered_list(
            filtered_players,
            by_subteam_used,
            lambda: reset_filter(used_players, "subteam", subteam)
        )
        used_players["subteam"][subteam] = list(by_subteam_used)

        save_state(used_players)
        print(f"Selected player: {selected['id']}")
        return selected

    available_players = [
        p for p in filtered_players if p["id"] not in by_default_used]
    print(f"Available players after default filter: {len(available_players)}")

    selected = select_from_filtered_list(
        filtered_players,
        by_default_used,
        lambda: used_players.__setitem__("global", [])
    )

    by_default_used.add(selected["id"])
    used_players["global"] = list(by_default_used)
    save_state(used_players)
    print(f"Selected player: {selected['id']}")

    return selected
